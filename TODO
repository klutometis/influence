# -*- org -*-
* TODO connectionist
# <<connectionist>>
  since $a_j(t + 1)$ depends on $a_j(t)$, we should calculate $t + 1$
  and then update the graph atomically: we can't let the $t + 1$
  contaminate $t$.
* TODO input specification
  can we just do something like this:
  
  #+BEGIN_SRC scheme
    (a 0.5)
    (b +high)
    (b -low)
    (c evidence)
    (a b +high)
    (c b -low)
    (a c 0.5)
  #+END_SRC

  or is that an appropriate way to handle evidence? do we need
  multiple evidence? let's just have a special (pre-existing) node to
  that effect:

  #+BEGIN_SRC scheme
    (a 0.5)
    (b +high)                               ; or (b high)
    (c -low)
    (a b +high)
    (evidence c -low)
    (a evidence 0.5)
  #+END_SRC

  so: we'll have nodes (activation) and links (weight, whence,
  whither); no name for now.

  actually:

  #+BEGIN_SRC scheme
    ;;; initial activations don't matter?
    (a)
    (b 0.5)
    (c 0.9 "Howdy Doody")
    
    (a b)
    (a c -0.5)
    
    (evidence a)
    (evidence c)
    
    ;;; all this (v. supra) is bad compared to the
    ;;; ({explain,contradict,...} ...) mechanisms; what's the big deal
    ;;; about key words, anyway?
    ;;; 
    ;;; would need to have the following to simulate (explain ...), etc.
    
    ((a b) c)
    ((a c) b -0.5)
    ((a b) evidence)
    
    ;;; should it look followingly instead?
    
    (use connectionist (decay 0.5) ...)
    
    (propose a)
    (propose b 0.75)
    (propose c -0.5 "Foo")
    
    ;;; though ECHO never really sets the initial activations for
    ;;; propositions; so maybe the following:
    
    (propose a)
    (propose b "Foo")
    (propose c "Bar")
    
    (explain (a c) b)
    (contradict (b) a)
    
    ;;; or simply:
    
    (contradict b a -0.75)
    
    (data a b)
    
    ;;; or maybe:
    
    (evidence a b)
    
    ;;; hmm.
  #+END_SRC

  what about joshua bloch's idea about starting with the API first?
  (see seibel's book.) hmm.

  #+BEGIN_SRC scheme :tangle influence.scm
    (module
     influence
     *
     (import scheme
             chicken)
    
     (use srfi-69
          defstruct
          matchable
          debug)
    
     (define default-activation 0.01)
     (define initial-activation default-activation)
     (define maximum-activation 0.99)
     (define minimum-activation -0.99)
    
     (define excitatory 0.04)
     (define inhibitory -0.06)
     (define default-weight excitatory)
    
     (define default-description "")
    
     (defstruct proposition
       (activation default-activation)
       (description default-description)
       ;; propositions are trivially accepted, rejected or something
       ;; orthogonal? a default of #t is trivially optimistic.
       (accepted? #t)
       (evidence? #f))
    
     (define evidence
       (make-proposition activation: maximum-activation
                         description: "Evidence"
                         evidence?: #t))
    
     (define (evidence? proposition)
       (eq? evidence proposition))
    
     (defstruct constraint
       (weight default-weight)
       whither)
    
     (defstruct problem
       (propositions
        ;; should we rethink this at some point?
        (let ((propositions (make-hash-table eq? hash-by-identity))) 
          (hash-table-set! propositions 'evidence evidence)
          propositions))
       (constraints (make-hash-table eq? hash-by-identity)))
    
     (define current-problem (make-parameter (make-problem)))
    
     (define link!
       (case-lambda
        ((problem whence whither)
         (link! problem whence whither default-weight))
        ((problem whence whither weight)
         (let* ((whither (hash-table-ref (problem-propositions problem)
                                         whither))
                (constraint (make-constraint weight: weight
                                             whither: whither)))
           (hash-table-update!/default
            (problem-constraints problem)
            whence
            (cut cons constraint <>)
            '())))))
    
    ;;; explain, contradict should call link-symmetrically! with
    ;;; e.g. certain default weights.
     (define link-symmetrically!
       (case-lambda
        ((problem whence whither)
         (link-symmetrically! problem whence whither default-weight))
        ((problem whence whither weight)
         (link! problem whence whither)
         (link! problem whither whence)))) 
    
     (define cohere!
       (case-lambda
        ((cohaeretors cohaerendum)
         (cohere! cohaeretors cohaerendum default-weight))
        ((cohaeretors cohaerendum weight)
         (cohere! (current-problem) cohaeretors cohaerendum weight))
        ((problem cohaeretors cohaerendum weight)
         (for-each
          (cut link-symmetrically! problem cohaerendum <> weight)
          cohaeretors)
         #;
         (let ((propositions (problem-propositions problem))
               (constraints (problem-constraints problem)))
           (let ((cohaerendum (hash-table-ref propositions cohaerendum)))
             (for-each
              (lambda (cohaeretor)
                (let ((cohaeretor (hash-table-ref propositions cohaeretor)))
                  (link-symmetrically! constraints cohaeretor cohaerendum weight)))
              cohaeretors))))))
    
    ;;; or maybe explain should do the symbol lookup, etc.
     (define explain!
       (case-lambda
        ((explanators explanandum)
         (explain! (current-problem) explanators explanandum))
        ((problem explanators explanandum)
         (cohere! problem explanators explanandum excitatory))))
    
     (define contradict!
       (case-lambda
        ((contradictors contradictum)
         (contradict! (current-problem) contradictors contradictum))
        ((problem contradictors contradictum)
         (cohere! problem contradictors contradictum inhibitory))))
    
     (define evidence!
       (case-lambda
        ((evidenced)
         (evidence! (current-problem) evidenced))
        ((problem evidenced)
         (explain! evidenced 'evidence))))
    
     (define propose!
       (case-lambda
        ((name)
         (propose! name default-activation))
        ((name activation)
         (propose! name activation default-description))
        ((name activation description)
         (propose! (current-problem) name activation description))
        ((problem name activation description)
         (hash-table-set!
          (problem-propositions problem)
          name
          (make-proposition activation description)))))
    
     (define (with-problem problem thunk)
       (parameterize ((current-problem problem)) (thunk))))    
    
  #+END_SRC

  do we want to have in-place mutation of the graph, btw? if we do a
  =hash-table-copy=, we're still going to have references to nodes;
  i'm beginning to see why david did the matrix thing.

  we're going to have to deep-copy the hash table in that case; if we
  merely used lists instead of e.g. node- and link-objects, that
  wouldn't be the case.

  bizarre, isn't it, that all nodes (save evidence) start off with an
  activation of 0.01? the input activations make no
  difference. interesting!

  what about abstractions like =proposition=, =explain=, =contradict=,
  etc.?

  otherwise, if we do an in-place calculation, we still have to hold
  $t + 1$ while calculating $t$ (see [[connectionist]]).

  if we're doing symmetrical links, btw, can't we have incoming and
  outgoing hash tables? although there's a space penalty, it becomes
  trivial to calculate McClelland's $S_j$: "the sum of the excitatory
  and inhibitory influences on unit $j$."

  incoming and outgoing hash-tables are orthogonal to symmetry;
  matrix-wise, however, aren't we dealing with transposing the
  adjacency matrix?

  in fact, we'd need two outgoing and two incoming links for each
  relationship in a symmetrical graph.

  #+BEGIN_SRC scheme :tangle test-hash-table.scm :shebang #!/usr/bin/env chicken-scheme
    (use srfi-69 debug test)
    
    (let ((table (make-hash-table)))
      (hash-table-update!/default
       table
       'a
       (lambda (value)
         (cons 1 value))
       '())
      (test
       "the default is passed to lambda as-is"
       '((a 1))
       (hash-table->alist table)))
  #+END_SRC

  thagard speaks of networks, units, links; but also: elements,
  constraints that underly the units and links. also: coherence
  problem, hypotheses.

  "In coherence theories of truth, the elements are propositions
  . . ." so we also have propositions.

  "Positive constraints can be a variety of relations among
  propositions, including entailment and also more complex relations
  such as explanation. The negative constraints can include
  inconsistency, but also weaker constraints such as competition."

  "Positive constraints arise from relations of explanation and
  analogy that hold between propositions, and negative constraints
  arise either because two hypotheses contradict each other or because
  they compete with each other to explain the same evidence."

  =echo-input.lisp= has: =(defun imply (lst prop) (explain lst
  prop))=, which is at least one synonym. but, in general,
  =proposition=, =explain=, =contradict= seem to suffice for the
  examples.

  let's have: problem, proposition, constraint.

  problem contexts for proposition, explain, et.nc

  #+BEGIN_SRC scheme :tangle test-with-parameter.scm :shebang #!/usr/bin/env chicken-scheme
    (use srfi-39 test)
    
    (define current-a (make-parameter 1))
    
    (define (with-a a thunk)
      (parameterize ((current-a a)) (thunk)))
    
    (with-a 2 (lambda () (test 2 (current-a))))
    
    (test 1 (current-a))
  #+END_SRC

  the verb associated with the bipartition of E into A and R is
  "satisfy": one "satisfies" a coherence problem. no, sorry; that's
  not true: one "solves" a coherence problem. (makes sense!)

  #+BEGIN_QUOTE
  To show that a given problem is a coherence problem in this sense,
  it is necessary to specify the elements and constraints, provide an
  interpretation of acceptance and rejection, and show that solutions
  to the given problem do in fact involve satisfaction of the
  specified constraints.
  #+END_QUOTE

  #+BEGIN_SRC scheme :tangle test-oj-problem.scm :shebang #!/usr/bin/env chicken-scheme
    (include "influence.scm")
    (import influence)
    (use debug srfi-1 matchable)
    
    (define (solve! problem)
      (define (clamp low high value)
        (max low (min high value)))
    
      (define decay 0.05)
    
      (define maximum-iterations 5000)
    
      (define (settled? delta)
        (zera? delta))
    
      (let ((propositions (problem-propositions problem))
            (constraints (problem-constraints problem)))
        (hash-table-walk
         propositions
         (lambda (name proposition)
           (if (not (proposition-evidence? proposition))
               (proposition-activation-set! proposition default-activation))))
        (let iterate ((iteration 0)
                      (delta +Inf))
          (debug iteration delta)
          (if (or (zero? delta)
                  (> iteration maximum-iterations))
              problem
              (let ((activations
                     (hash-table-fold
                      propositions
                      (lambda (name proposition activations)
                        (let ((activation
                               (if (proposition-evidence? proposition)
                                   (proposition-activation proposition)
                                   (let ((incoming-activation
                                          (apply + (map (compose proposition-activation
                                                                 constraint-whither)
                                                        (hash-table-ref constraints
                                                                        name))))
                                         (activation (proposition-activation proposition)))
                                     (+ (* activation (- 1 decay))
                                        (* incoming-activation
                                           (if (positive? incoming-activation)
                                               (- maximum-activation activation)
                                               (- activation minimum-activation))))))))
                          (alist-cons name
                                      (clamp minimum-activation
                                             maximum-activation
                                             activation)
                                      activations)))
                      '())))
                ;; do we need this read step, or can we simply update and take
                ;; the delta? let's update and take the delta. no; unless we
                ;; mutate, we need to read the delta.
                (let ((delta
                       (apply +
                              (map (match-lambda
                                       ((name . activation)
                                        (- activation
                                           (proposition-activation
                                            (hash-table-ref propositions name)))))
                                   activations)))) 
                  (for-each (match-lambda
                                ((name . activation)
                                 (hash-table-update! propositions
                                                     name
                                                     (lambda (proposition)
                                                       (proposition-activation-set!
                                                        proposition
                                                        activation)
                                                       proposition))))
                            activations)
                  (iterate (add1 iteration)
                           delta)))))))
    
    (let ((oj (make-problem)))
      (with-problem
       oj
       (lambda ()
         (propose! 'oj-abusive)
         (propose! 'oj-beat-nicole)
         (propose! 'oj-killed-nicole)
         (propose! 'nicole-and-ron-were-killed)
         (propose! 'blood-on-sock)
         (propose! 'blood-in-ojs-car)
         (propose! 'bloody-glove)
         (propose! 'bloody-gate)
         (propose! 'fuhrman-lied)
         (propose! 'edta-on-sock)
         (propose! 'drug-dealers-killed-nicole)
         (propose! 'the-lapd-framed-oj)
    
         (explain! '(oj-beat-nicole oj-killed-nicole) 'oj-abusive)
         (explain! '(blood-on-sock
                     blood-in-ojs-car
                     bloody-glove
                     bloody-gate
                     fuhrman-lied
                     edta-on-sock)
                   'the-lapd-framed-oj)
    
         (contradict! '(drug-dealers-killed-nicole
                        the-lapd-framed-oj)
                      'oj-killed-nicole)
    
         (evidence! '(oj-beat-nicole
                      nicole-and-ron-were-killed
                      blood-on-sock
                      blood-in-ojs-car
                      bloody-glove
                      bloody-gate
                      fuhrman-lied
                      edta-on-sock)) 
    
         (debug (solve! oj)))))
    
  #+END_SRC

  what does it mean to solve a coherence problem, btw? bipartition of
  propositions into accepted or rejected. if we're doing this
  in-place, we can simply set a flag on the proposition to =accepted?
  => #t=.

  think along the lines of =(solve problem solver)=, where =solver= is
  e.g. connectionist instantiated with certain parameters =(decay
  0.5)=, etc.

  #+BEGIN_SRC scheme :tangle test-fold.scm :shebang #!/usr/bin/env chicken-scheme
    (use srfi-1 debug)
    
    (debug
     (fold (lambda (a b c)
             (debug a b c)
             (+ a b c))
           0
           '(1 2)
           '(3 4)))
    
  #+END_SRC

  figure out a way to [[http://orgmode.org/manual/System_002dwide-header-arguments.html#System_002dwide-header-arguments][set the default :shebang]]; this doesn't work:

  #+BEGIN_SRC elisp
    (setq org-babel-default-header-args:scheme
          '((:shebang . "#!/usr/bin/env chicken-scheme")))
  #+END_SRC

  [[http://www.mail-archive.com/emacs-orgmode@gnu.org/msg37217.html][see this]].

  #+BEGIN_SRC scheme :tangle test-equality.scm :shebang #!/usr/bin/env chicken-scheme
    (use defstruct debug srfi-69 srfi-9)
    
    (defstruct a (b 1))
    
    (let ((table (make-hash-table eq?))
          (a (make-a)))
      (hash-table-set! table a 2)
      (hash-table-ref table a)
      (a-b-set! a 2)
      ;; this throws an error! is it doing some sort of deep comparison,
      ;; or copy-on-write?
      (hash-table-ref table a))
    
  #+END_SRC

  #+BEGIN_SRC scheme :tangle test-range.scm :shebang #!/usr/bin/env chicken-scheme
    (use debug srfi-26)
    
    (define (clamp low high value)
      (max low (min high value)))
    
    (let ((min-n -1)
          (max-n 1)
          (x 9)
          (y -9)
          (z 0))
      (debug
       (map (cut clamp min-n max-n <>)
            (list x y z))))
    
  #+END_SRC

  how to visualize $t$: time series?
