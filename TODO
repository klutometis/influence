# -*- org -*-
* TODO connectionist
# <<connectionist>>
  since $a_j(t + 1)$ depends on $a_j(t)$, we should calculate $t + 1$
  and then update the graph atomically: we can't let the $t + 1$
  contaminate $t$.
* TODO input specification
  can we just do something like this:
  
  #+BEGIN_SRC scheme
    (a 0.5)
    (b +high)
    (b -low)
    (c evidence)
    (a b +high)
    (c b -low)
    (a c 0.5)
  #+END_SRC

  or is that an appropriate way to handle evidence? do we need
  multiple evidence? let's just have a special (pre-existing) node to
  that effect:

  #+BEGIN_SRC scheme
    (a 0.5)
    (b +high)                               ; or (b high)
    (c -low)
    (a b +high)
    (evidence c -low)
    (a evidence 0.5)
  #+END_SRC

  so: we'll have nodes (activation) and links (weight, whence,
  whither); no name for now.

  #+BEGIN_SRC scheme :tangle influence.scm
    (module
     influence
     *
     (import scheme
             chicken)
    
     (use srfi-69
          defstruct
          matchable
          debug)
    
     (define default-activation 0.01)
     (define initial-activation default-activation)
     (define maximum-activation 0.99)
     (define minimum-activation -0.99)
    
     (define excitatory 0.04)
     (define inhibitory -0.06)
     (define default-weight excitatory)
    
     (define default-description "")
    
     (defstruct proposition
       (activation default-activation)
       (description default-description))
    
     (define evidence
       (make-proposition activation: maximum-activation
                         description: "Evidence"))
    
     (define (evidence? proposition)
       (eq? evidence proposition))
    
     (defstruct constraint
       (weight default-weight)
       whither)
    
     (defstruct problem
       (propositions
        ;; should we rethink this at some point?
        (let ((propositions (make-hash-table eq? hash-by-identity)))
          (hash-table-set! propositions 'evidence evidence)
          propositions))
       (constraints (make-hash-table eq? hash-by-identity)))
    
     (define current-problem (make-parameter (make-problem)))
    
     (define link!
       (case-lambda
        ((constraints whence whither)
         (link! constraints whence whither default-weight))
        ((constraints whence whither weight)
         (let ((constraint (make-constraint weight: weight
                                            whither: whither)))
           (hash-table-update!/default
            constraints
            whence
            (cut cons constraint <>)
            '())))))
    
    ;;; explain, contradict should call link-symmetrically! with
    ;;; e.g. certain default weights.
     (define link-symmetrically!
       (case-lambda
        ((constraints whence whither)
         (link-symmetrically! constraints whence whither default-weight))
        ((constraints whence whither weight)
         (link! constraints whence whither)
         (link! constraints whither whence)))) 
    
     (define cohere!
       (case-lambda
        ((cohaeretors cohaerendum)
         (cohere! cohaeretors cohaerendum default-weight))
        ((cohaeretors cohaerendum weight)
         (current-problem cohaeretors cohaerendum weight))
        ((problem cohaeretors cohaerendum weight)
         (let ((propositions (problem-propositions problem))
               (constraints (problem-constraints problem)))
           (let ((cohaerendum (hash-table-ref propositions cohaerendum)))
             (for-each
              (lambda (cohaeretor)
                (let ((cohaeretor (hash-table-ref propositions cohaeretor)))
                  (link-symmetrically! constraints cohaeretor cohaerendum weight)))
              cohaeretors))))))
    
    ;;; or maybe explain should do the symbol lookup, etc.
     (define explain!
       (case-lambda
        ((explanators explanandum)
         (explain! (current-problem) explanators explanandum))
        ((problem explanators explanandum)
         (cohere! problem explanators explanandum excitatory))))
    
     (define contradict!
       (case-lambda
        ((contradictors contradictum)
         (contradict! (current-problem) contradictors contradictum))
        ((problem contradictors contradictum)
         (cohere! problem contradictors contradictum inhibitory))))
    
     (define evidence!
       (case-lambda
        ((evidenced)
         (evidence! (current-problem) evidenced))
        ((problem evidenced)
         (explain! evidenced 'evidence))))
    
     (define propose!
       (case-lambda
        ((name)
         (propose! name default-activation))
        ((name activation)
         (propose! name activation default-description))
        ((name activation description)
         (propose! (current-problem) name activation description))
        ((problem name activation description)
         (hash-table-set!
          (problem-propositions problem)
          name
          (make-proposition activation description)))))
    
     (define (with-problem problem thunk)
       (parameterize ((current-problem problem)) (thunk))))
    
  #+END_SRC

  do we want to have in-place mutation of the graph, btw? if we do a
  =hash-table-copy=, we're still going to have references to nodes;
  i'm beginning to see why david did the matrix thing.

  we're going to have to deep-copy the hash table in that case; if we
  merely used lists instead of e.g. node- and link-objects, that
  wouldn't be the case.

  bizarre, isn't it, that all nodes (save evidence) start off with an
  activation of 0.01? the input activations make no
  difference. interesting!

  what about abstractions like =proposition=, =explain=, =contradict=,
  etc.?

  otherwise, if we do an in-place calculation, we still have to hold
  $t + 1$ while calculating $t$ (see [[connectionist]]).

  if we're doing symmetrical links, btw, can't we have incoming and
  outgoing hash tables? although there's a space penalty, it becomes
  trivial to calculate McClelland's $S_j$: "the sum of the excitatory
  and inhibitory influences on unit $j$."

  incoming and outgoing hash-tables are orthogonal to symmetry;
  matrix-wise, however, aren't we dealing with transposing the
  adjacency matrix?

  in fact, we'd need two outgoing and two incoming links for each
  relationship in a symmetrical graph.

  #+BEGIN_SRC scheme :tangle test-hash-table.scm :shebang #!/usr/bin/env chicken-scheme
    (use srfi-69 debug test)
    
    (let ((table (make-hash-table)))
      (hash-table-update!/default
       table
       'a
       (lambda (value)
         (cons 1 value))
       '())
      (test
       "the default is passed to lambda as-is"
       '((a 1))
       (hash-table->alist table)))
  #+END_SRC

  thagard speaks of networks, units, links; but also: elements,
  constraints that underly the units and links. also: coherence
  problem, hypotheses.

  "In coherence theories of truth, the elements are propositions
  . . ." so we also have propositions.

  "Positive constraints can be a variety of relations among
  propositions, including entailment and also more complex relations
  such as explanation. The negative constraints can include
  inconsistency, but also weaker constraints such as competition."

  "Positive constraints arise from relations of explanation and
  analogy that hold between propositions, and negative constraints
  arise either because two hypotheses contradict each other or because
  they compete with each other to explain the same evidence."

  =echo-input.lisp= has: =(defun imply (lst prop) (explain lst
  prop))=, which is at least one synonym. but, in general,
  =proposition=, =explain=, =contradict= seem to suffice for the
  examples.

  let's have: problem, proposition, constraint.

  problem contexts for proposition, explain, et.nc

  #+BEGIN_SRC scheme :tangle test-with-parameter.scm :shebang #!/usr/bin/env chicken-scheme
    (use srfi-39 test)
    
    (define current-a (make-parameter 1))
    
    (define (with-a a thunk)
      (parameterize ((current-a a)) (thunk)))
    
    (with-a 2 (lambda () (test 2 (current-a))))
    
    (test 1 (current-a))
  #+END_SRC

  the verb associated with the bipartition of E into A and R is
  "satisfy": one "satisfies" a coherence problem. no, sorry; that's
  not true: one "solves" a coherence problem. (makes sense!)

  #+BEGIN_QUOTE
  To show that a given problem is a coherence problem in this sense,
  it is necessary to specify the elements and constraints, provide an
  interpretation of acceptance and rejection, and show that solutions
  to the given problem do in fact involve satisfaction of the
  specified constraints.
  #+END_QUOTE

  #+BEGIN_SRC scheme :tangle test-oj-problem.scm :shebang #!/usr/bin/env chicken-scheme
    (include "influence.scm")
    (import influence)
    
    (let ((oj (make-problem)))
      (with-problem
       oj
       (lambda ()
         (propose! 'oj-abusive)
         (propose! 'oj-beat-nicole)
         (propose! 'oj-killed-nicole)
         (propose! 'nicole-and-ron-were-killed)
         (propose! 'blood-on-sock)
         (propose! 'blood-in-ojs-car)
         (propose! 'bloody-glove)
         (propose! 'bloody-gate)
         (propose! 'fuhrman-lied)
         (propose! 'edta-on-sock)
         (propose! 'drug-dealers-killed-nicole)
         (propose! 'the-lapd-framed-oj)
    
         (explain! '(oj-beat-nicole oj-killed-nicole) 'oj-abusive)
         (explain! '(blood-on-sock
                     blood-in-ojs-car
                     bloody-glove
                     bloody-gate
                     fuhrman-lied
                     edta-on-sock)
                   'the-lapd-framed-oj)
    
         (contradict! '(drug-dealers-killed-nicole
                        the-lapd-framed-oj)
                      'oj-killed-nicole)
    
         (evidence! '(oj-beat-nicole
                      nicole-and-ron-were-killed
                      blood-on-sock
                      blood-in-ojs-car
                      bloody-glove
                      bloody-gate
                      fuhrman-lied
                      edta-on-sock)) 
    
         'harro)))    
  #+END_SRC
