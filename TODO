# -*- org -*-
* DONE connectionist
  CLOSED: [2011-02-23 Wed 01:41]
# <<connectionist>>
  since $a_j(t + 1)$ depends on $a_j(t)$, we should calculate $t + 1$
  and then update the graph atomically: we can't let the $t + 1$
  contaminate $t$.
* DONE input specification
  CLOSED: [2011-02-23 Wed 01:41]
  can we just do something like this:
  
  #+BEGIN_SRC scheme
    (a 0.5)
    (b +high)
    (b -low)
    (c evidence)
    (a b +high)
    (c b -low)
    (a c 0.5)
  #+END_SRC

  or is that an appropriate way to handle evidence? do we need
  multiple evidence? let's just have a special (pre-existing) node to
  that effect:

  #+BEGIN_SRC scheme
    (a 0.5)
    (b +high)                               ; or (b high)
    (c -low)
    (a b +high)
    (evidence c -low)
    (a evidence 0.5)
  #+END_SRC

  so: we'll have nodes (activation) and links (weight, whence,
  whither); no name for now.

  actually:

  #+BEGIN_SRC scheme
    ;;; initial activations don't matter?
    (a)
    (b 0.5)
    (c 0.9 "Howdy Doody")
    
    (a b)
    (a c -0.5)
    
    (evidence a)
    (evidence c)
    
    ;;; all this (v. supra) is bad compared to the
    ;;; ({explain,contradict,...} ...) mechanisms; what's the big deal
    ;;; about key words, anyway?
    ;;; 
    ;;; would need to have the following to simulate (explain ...), etc.
    
    ((a b) c)
    ((a c) b -0.5)
    ((a b) evidence)
    
    ;;; should it look followingly instead?
    
    (use connectionist (decay 0.5) ...)
    
    (propose a)
    (propose b 0.75)
    (propose c -0.5 "Foo")
    
    ;;; though ECHO never really sets the initial activations for
    ;;; propositions; so maybe the following:
    
    (propose a)
    (propose b "Foo")
    (propose c "Bar")
    
    (explain (a c) b)
    (contradict (b) a)
    
    ;;; or simply:
    
    (contradict b a -0.75)
    
    (data a b)
    
    ;;; or maybe:
    
    (evidence a b)
    
    ;;; hmm.
  #+END_SRC

  what about joshua bloch's idea about starting with the API first?
  (see seibel's book.) hmm.

  #+BEGIN_SRC scheme :tangle test-influence-module.scm
    (module
     influence
     *
     (import scheme
             chicken)
    
     (use srfi-69
          defstruct
          matchable
          debug)
    
     (define default-activation (make-parameter 0.01))
     (define maximum-activation (make-parameter 0.99))
     (define minimum-activation (make-parameter -0.99))
    
     (define excitatory (make-parameter 0.04))
     (define inhibitory (make-parameter -0.06))
     (define default-weight (make-parameter (excitatory)))
    
     (define default-description (make-parameter ""))
    
     (define (default-description? description)
       (string=? description (default-description)))
    
     (defstruct proposition
       name
       (activation (default-activation))
       (description (default-description))
       ;; propositions are trivially accepted, rejected or something
       ;; orthogonal? a default of #t is trivially optimistic.
       (accepted? #t)
       (evidence? #f))
    
     (define evidence
       (make-proposition
        name: 'evidence
        activation: (maximum-activation)
        description: "Evidence"
        evidence?: #t))
    
     (define (evidence? proposition)
       (eq? evidence proposition))
    
     (defstruct constraint
       (weight (default-weight))
       whither)
    
     (defstruct problem
       (propositions
        ;; should we rethink this at some point?
        (let ((propositions (make-hash-table eq? hash-by-identity))) 
          (hash-table-set! propositions 'evidence evidence)
          propositions))
       (constraints (make-hash-table eq? hash-by-identity)))
    
     (define current-problem (make-parameter (make-problem)))
    
     (define link!
       (case-lambda
        ((problem whence whither)
         (link! problem whence whither (default-weight)))
        ((problem whence whither weight)
         (let* ((whither (hash-table-ref (problem-propositions problem)
                                         whither))
                (constraint (make-constraint weight: weight
                                             whither: whither)))
           (hash-table-update!/default
            (problem-constraints problem)
            whence
            (cut cons constraint <>)
            '())))))
    
    ;;; explain, contradict should call link-symmetrically! with
    ;;; e.g. certain default weights.
     (define link-symmetrically!
       (case-lambda
        ((problem whence whither)
         (link-symmetrically! problem whence whither (default-weight)))
        ((problem whence whither weight)
         (link! problem whence whither weight)
         (link! problem whither whence weight)))) 
    
     (define cohere!
       (case-lambda
        ((cohaeretors cohaerendum)
         (cohere! cohaeretors cohaerendum (default-weight)))
        ((cohaeretors cohaerendum weight)
         (cohere! (current-problem) cohaeretors cohaerendum weight))
        ((problem cohaeretors cohaerendum weight)
         (for-each
          (cut link-symmetrically! problem cohaerendum <> weight)
          cohaeretors)
         #;
         (let ((propositions (problem-propositions problem))
               (constraints (problem-constraints problem)))
           (let ((cohaerendum (hash-table-ref propositions cohaerendum)))
             (for-each
              (lambda (cohaeretor)
                (let ((cohaeretor (hash-table-ref propositions cohaeretor)))
                  (link-symmetrically! constraints cohaeretor cohaerendum weight)))
              cohaeretors))))))
    
    ;;; or maybe explain should do the symbol lookup, etc.
     (define explain!
       (case-lambda
        ((explanators explanandum)
         (explain! (current-problem) explanators explanandum))
        ((problem explanators explanandum)
         (cohere! problem explanators explanandum (excitatory)))))
    
     (define contradict!
       (case-lambda
        ((contradictors contradictum)
         (contradict! (current-problem) contradictors contradictum))
        ((problem contradictors contradictum)
         (cohere! problem contradictors contradictum (inhibitory)))))
    
     (define evidence!
       (case-lambda
        ((evidenced)
         (evidence! (current-problem) evidenced))
        ((problem evidenced)
         (explain! evidenced 'evidence))))
    
     (define propose!
       (case-lambda
        ((name)
         (propose! name (default-description)))
        ((name description)
         (propose! name description (default-activation)))
        ((name description activation)
         (propose! (current-problem) name description activation))
        ((problem name description activation)
         (hash-table-set!
          (problem-propositions problem)
          name
          (make-proposition name: name
                            activation: activation
                            description: description)))))
    
     (define (with-problem problem thunk)
       (parameterize ((current-problem problem)) (thunk))))    
    
  #+END_SRC

  do we want to have in-place mutation of the graph, btw? if we do a
  =hash-table-copy=, we're still going to have references to nodes;
  i'm beginning to see why david did the matrix thing.

  we're going to have to deep-copy the hash table in that case; if we
  merely used lists instead of e.g. node- and link-objects, that
  wouldn't be the case.

  bizarre, isn't it, that all nodes (save evidence) start off with an
  activation of 0.01? the input activations make no
  difference. interesting!

  what about abstractions like =proposition=, =explain=, =contradict=,
  etc.?

  otherwise, if we do an in-place calculation, we still have to hold
  $t + 1$ while calculating $t$ (see [[connectionist]]).

  if we're doing symmetrical links, btw, can't we have incoming and
  outgoing hash tables? although there's a space penalty, it becomes
  trivial to calculate McClelland's $S_j$: "the sum of the excitatory
  and inhibitory influences on unit $j$."

  incoming and outgoing hash-tables are orthogonal to symmetry;
  matrix-wise, however, aren't we dealing with transposing the
  adjacency matrix?

  in fact, we'd need two outgoing and two incoming links for each
  relationship in a symmetrical graph.

  #+BEGIN_SRC scheme :tangle test-hash-table.scm :shebang #!/usr/bin/env chicken-scheme
    (use srfi-69 debug test)
    
    (let ((table (make-hash-table)))
      (hash-table-update!/default
       table
       'a
       (lambda (value)
         (cons 1 value))
       '())
      (test
       "the default is passed to lambda as-is"
       '((a 1))
       (hash-table->alist table)))
  #+END_SRC

  thagard speaks of networks, units, links; but also: elements,
  constraints that underly the units and links. also: coherence
  problem, hypotheses.

  "In coherence theories of truth, the elements are propositions
  . . ." so we also have propositions.

  "Positive constraints can be a variety of relations among
  propositions, including entailment and also more complex relations
  such as explanation. The negative constraints can include
  inconsistency, but also weaker constraints such as competition."

  "Positive constraints arise from relations of explanation and
  analogy that hold between propositions, and negative constraints
  arise either because two hypotheses contradict each other or because
  they compete with each other to explain the same evidence."

  =echo-input.lisp= has: =(defun imply (lst prop) (explain lst
  prop))=, which is at least one synonym. but, in general,
  =proposition=, =explain=, =contradict= seem to suffice for the
  examples.

  let's have: problem, proposition, constraint.

  problem contexts for proposition, explain, et.nc

  #+BEGIN_SRC scheme :tangle test-with-parameter.scm :shebang #!/usr/bin/env chicken-scheme
    (use srfi-39 test)
    
    (define current-a (make-parameter 1))
    
    (define (with-a a thunk)
      (parameterize ((current-a a)) (thunk)))
    
    (with-a 2 (lambda () (test 2 (current-a))))
    
    (test 1 (current-a))
  #+END_SRC

  the verb associated with the bipartition of E into A and R is
  "satisfy": one "satisfies" a coherence problem. no, sorry; that's
  not true: one "solves" a coherence problem. (makes sense!)

  #+BEGIN_QUOTE
  To show that a given problem is a coherence problem in this sense,
  it is necessary to specify the elements and constraints, provide an
  interpretation of acceptance and rejection, and show that solutions
  to the given problem do in fact involve satisfaction of the
  specified constraints.
  #+END_QUOTE

  #+BEGIN_SRC scheme :tangle test-oj-problem.scm :shebang #!/usr/bin/env chicken-scheme
    (include "test-influence-module.scm")
    (import files influence)
    (use debug
         srfi-1
         matchable
         format
         posix
         foof-loop
         shell
         defstruct)
    
    (define maximum-iterations (make-parameter 5000))
    
    (define decay (make-parameter 0.05))
    
    (define epsilon (make-parameter 0.001))
    
    (define initial-activation (make-parameter (default-activation)))
    
    (define (display-problem/dot problem)
      (define (activation->saturation activation)
        (- 255 (inexact->exact (floor (* (/ activation (if (positive? activation)
                                                           (maximum-activation)
                                                           (minimum-activation)))
                                         255)))))
      
      (let ((document "digraph G { graph [size=\"12!\", ratio=0.618033989]; node [style=filled]; edge [dir=none]; ~a ~a }"))
        ;; what about writing right away, and not gathering?
        (let ((propositions
               (hash-table-fold
                (problem-propositions problem)
                (lambda (name proposition nodes)
                  (cons
                   (let* ((activation (proposition-activation proposition))
                          (saturation (activation->saturation activation)))
                     (format "\"~a\" [label=\"~a\", fillcolor=\"#~a~a~a\"];"
                             name
                             (let ((description
                                    (proposition-description proposition)))
                               (if (default-description? description)
                                   name
                                   #;description
                                   name
                                   ))
                             (format "~2,48X" (if (negative? activation)
                                                  255
                                                  saturation))
                             (format "~2,48X" (if (positive? activation)
                                                  255
                                                  saturation))
                             (format "~2,48X" saturation)))
                   nodes))
                '()))
              ;; respect sign and scale with dashed/solid and thickness?
              (constraints
               (map
                (match-lambda
                    ((whence whither . weight)
                     (format "\"~a\" -> \"~a\" [style=~a];"
                             whence
                             whither
                             (if (positive? weight)
                                 "solid"
                                 "dashed"))))
                ;; it's damn-expensive to delete one edge in a
                ;; bidirectional graph; we might want to consider
                ;; switching to a unidirectional graph, simulating
                ;; bidirectionality.
                (delete-duplicates
                 (hash-table-fold
                  (problem-constraints problem)
                  (lambda (name constraints edges)
                    (append
                     (map (lambda (constraint)
                            (cons* name
                                   (proposition-name
                                    (constraint-whither constraint))
                                   (constraint-weight constraint)))
                          constraints)
                     edges))
                  '())
                 (lambda (edge-a edge-b)
                   (match-let (((a-whence a-whither . a-weight) edge-a)
                               ((b-whence b-whither . b-weight) edge-b))
                     (and (eq? a-whence b-whither)
                          (eq? b-whence a-whither))))))))
          (format #t
                  document
                  (string-join propositions)
                  (string-join constraints)))))
    
    (define (clamp low high value)
      (max low (min high value)))
    
    (define cardinality
      (case-lambda
       ((integer) (cardinality integer 10))
       ((integer base)
        (loop ((for power (up-from 0))
               (until (> (expt base power) integer)))
              => power))))
    
    (defstruct processor pre-process process post-process)
    
    (define (make-animation-processor animation)
      (let ((temp-dir (create-temporary-directory))
            (temp-digits (cardinality (maximum-iterations))))
        (let ((output-template
               (format "~~~a,48d.gif" temp-digits)))
          (make-processor
           pre-process: noop
           process:
           (lambda (problem iteration)
             (let-values
                 (((in out id)
                   (process
                    "dot" `("-Tgif"
                            "-o" ,(make-pathname temp-dir
                                                 (format output-template
                                                         iteration))))))
               (close-input-port in)
               (with-output-to-port
                   out
                 (lambda () (display-problem/dot problem)))
               (close-output-port out)))
           post-process:
           (lambda (problem)
             (run (convert "$(" find ,temp-dir -name \'*.gif\' \| sort &&
                           find ,temp-dir -name \'*.gif\' \| sort -r ")"
                           -loop 0 ,animation)))))))
    
    (define (make-time-series-processor time-series)
      (let ((time-series-data (create-temporary-file)))
        (make-processor
         pre-process: noop
         process:
         (let ((time-series-data (open-output-file time-series-data)))
           (lambda (problem iteration)
             (display (string-join
                       (map
                        (compose number->string proposition-activation)
                        (hash-table-values (problem-propositions problem))))
                      time-series-data)
             (newline time-series-data)))
         post-process:
         (lambda (problem)
           (let ((propositions (problem-propositions problem))
                 (document "set term pngcairo size 1024,768 font \",8\" enhanced crop; set output \"~a\"; plot ~a
    "))
             (let ((elements
                    (loop ((for name (in-list (hash-table-keys propositions)))
                           (for proposition
                                (in-list (hash-table-values propositions)))
                           (for column (up-from 1))
                           (for elements
                                (listing
                                 (format "\"~a\" using ~a with lines title \"~a\""
                                         time-series-data
                                         column
                                         name))))
                          => elements)))
               (let-values (((in out id) (process "gnuplot")))
                 (close-input-port in)
                 (format
                  out
                  document
                  time-series
                  (string-join elements ", "))
                 (close-output-port out))))))))
    
    (define solve!
      (case-lambda
       ((algorithm) (solve! algorithm (current-problem)))
       ((algorithm problem) (algorithm problem))))
    
    (define (connectionist . processors)
      (lambda (problem)
        (let ((propositions (problem-propositions problem))
              (constraints (problem-constraints problem)))
          (hash-table-walk
           propositions
           (lambda (name proposition)
             (if (not (proposition-evidence? proposition))
                 (proposition-activation-set! proposition (initial-activation)))))
          (for-each (lambda (processor)
                      ((processor-pre-process processor) problem))
                    processors)
          (let iterate ((iteration 0)
                        (delta +Inf))
            (if (or (< (abs delta) (epsilon))
                    (> iteration (maximum-iterations)))
                (begin
                  (for-each (lambda (processor)
                              ((processor-post-process processor) problem))
                            processors)
                  problem)
                (let ((activations
                       (hash-table-fold
                        propositions
                        (lambda (name proposition activations)
                          (let ((activation
                                 (if (proposition-evidence? proposition)
                                     (proposition-activation proposition)
                                     (let ((incoming-activation
                                            (let ((constraints (hash-table-ref constraints name)))
                                              (apply +
                                                     (map *
                                                          (map constraint-weight constraints)
                                                          (map (compose proposition-activation
                                                                        constraint-whither)
                                                               constraints)))))
                                           (activation (proposition-activation proposition)))
                                       (+ (* activation (- 1 (decay)))
                                          (* incoming-activation
                                             (if (positive? incoming-activation)
                                                 (- (maximum-activation) activation)
                                                 (- activation (minimum-activation)))))))))
                            (alist-cons name
                                        (clamp (minimum-activation)
                                               (maximum-activation)
                                               activation)
                                        activations)))
                        '()))) 
                  ;; do we need this read step, or can we simply update and take
                  ;; the delta? let's update and take the delta. no; unless we
                  ;; mutate, we need to read the delta.
                  (let ((delta
                         (apply +
                                (map (match-lambda
                                         ((name . activation)
                                          (- activation
                                             (proposition-activation
                                              (hash-table-ref propositions name)))))
                                     activations)))) 
                    (for-each (match-lambda
                                  ((name . activation)
                                   (hash-table-update! propositions
                                                       name
                                                       (lambda (proposition)
                                                         (proposition-activation-set!
                                                          proposition
                                                          activation)
                                                         proposition))))
                              activations)
                    (for-each (lambda (processor)
                                ((processor-process processor) problem iteration))
                              processors)
                    (iterate (add1 iteration)
                             delta))))))))
    
    (with-problem
     (make-problem)
     (lambda ()
       (propose! 'oj-abusive)
       (propose! 'oj-beat-nicole)
       (propose! 'oj-killed-nicole)
       (propose! 'nicole-and-ron-were-killed)
       (propose! 'blood-on-sock)
       (propose! 'blood-in-ojs-car)
       (propose! 'bloody-glove)
       (propose! 'bloody-gate)
       (propose! 'fuhrman-lied)
       (propose! 'edta-on-sock)
       (propose! 'drug-dealers-killed-nicole)
       (propose! 'the-lapd-framed-oj)
    
       (explain! '(oj-beat-nicole oj-killed-nicole) 'oj-abusive)
       (explain! '(blood-on-sock
                   blood-in-ojs-car
                   bloody-glove
                   bloody-gate
                   fuhrman-lied
                   edta-on-sock)
                 'the-lapd-framed-oj)
       (explain! '(nicole-and-ron-were-killed)
                 'drug-dealers-killed-nicole)
    
       (contradict! '(drug-dealers-killed-nicole
                      the-lapd-framed-oj)
                    'oj-killed-nicole)
    
       (evidence! '(oj-beat-nicole
                    nicole-and-ron-were-killed
                    blood-on-sock
                    blood-in-ojs-car
                    bloody-glove
                    bloody-gate
                    fuhrman-lied
                    edta-on-sock)) 
    
       (display-problem/dot
        (solve! (connectionist
                 (make-animation-processor "oj.gif")
                 (make-time-series-processor "oj-series.png"))))))
    
    #;
    (with-problem
     (make-problem)
     (lambda ()
       (propose! 'e1)
       (propose! 'e2)
       (propose! 'e3)
       (propose! 'e4)
    
       (explain! '(e3 e4) 'e1)
       (explain! '(e4) 'e2)
    
       (contradict! '(e1) 'e2)
    
       (evidence! '(e1))
    
       (display-problem/dot (solve! (current-problem)))))
    
     #;
     (with-problem
      (make-problem)
      (lambda ()
        (propose! 'E1 "In combustion, heat and light are given off.")
        (propose! 'E2 "Inflammability is transmittable from one body to another.")
        (propose! 'E3 "Combustion only occurs in the presence of pure air.")
        (propose! 'E4 "Increase in weight of a burned body is exactly equal to weight of air absorbed. ")
        (propose! 'E5 "Metals undergo calcination.")
        (propose! 'E6 "In calcination, bodies increase weight.")
        (propose! 'E7 "In calcination, volume of air diminishes.") ; 628
        (propose! 'E8 "In reduction, effervescence appears.")      ; 628
    
        (propose! 'OH1 "Pure air contains oxygen principle.") ; 625
        (propose! 'OH2 "Pure air contains matter of fire and heat (MFH).") ;
        (propose! 'OH3 "In combustion, oxygen from the air combines with the burning body.")
        (propose! 'OH4 "Oxygen has weight.")
        (propose! 'OH5 "In calcination, metals add oxygen to become calxes. ")
        (propose! 'OH6 "In reduction, oxygen is given off.") ; 628
    
        (propose! 'PH1 "Combustible bodies contain phlogiston.")     ; 624
        (propose! 'PH2 "Combustible bodies contain matter of heat.") ; 652
        (propose! 'PH3 "In combustion, phlogiston is given off.")    ; 624
        (propose! 'PH4 "Phlogiston can pass from one body to another.") ; 625
        (propose! 'PH5 "Metals contain phlogiston.")               ; 624
        (propose! 'PH6 "In calcination, phlogiston is given off.") ; 624
    
                                            ; Contradictions:
    
        (contradict! '(PH3) 'OH3)
        (contradict! '(PH6) 'OH5)           ; 652
    
                                            ; Oxygen explanations:
        (explain! '(OH1 OH2 OH3) 'E1)
                                            ; E2?
        (explain! '(OH1 OH3) 'E3)
        (explain! '(OH1 OH3 OH4) 'E4)
        (explain! '(OH1 OH5) 'E5)
        (explain! '(OH1 OH4 OH5) 'E6)
        (explain! '(OH1 OH5) 'E7)
        (explain! '(OH1 OH6) 'E8)
    
                                            ; Phlogiston explanations:
        (explain! '(PH1 PH2 PH3) 'E1)
        (explain! '(PH1 PH3 PH4) 'E2)
        (explain! '(PH5 PH6) 'E5)
    
        (evidence! '(E1 E2 E3 E4 E5 E6 E7 E8))
    
        (display-problem/dot (solve! (current-problem)))))
    
  #+END_SRC

  what does it mean to solve a coherence problem, btw? bipartition of
  propositions into accepted or rejected. if we're doing this
  in-place, we can simply set a flag on the proposition to =accepted?
  => #t=.

  think along the lines of =(solve problem solver)=, where =solver= is
  e.g. connectionist instantiated with certain parameters =(decay
  0.5)=, etc.

  #+BEGIN_SRC scheme :tangle test-fold.scm :shebang #!/usr/bin/env chicken-scheme
    (use srfi-1 debug)
    
    (debug
     (fold (lambda (a b c)
             (debug a b c)
             (+ a b c))
           0
           '(1 2)
           '(3 4)))
    
  #+END_SRC

  figure out a way to [[http://orgmode.org/manual/System_002dwide-header-arguments.html#System_002dwide-header-arguments][set the default :shebang]]; this doesn't work:

  #+BEGIN_SRC elisp
    (setq org-babel-default-header-args:scheme
          '((:shebang . "#!/usr/bin/env chicken-scheme")))
  #+END_SRC

  [[http://www.mail-archive.com/emacs-orgmode@gnu.org/msg37217.html][see this]].

  #+BEGIN_SRC scheme :tangle test-equality.scm :shebang #!/usr/bin/env chicken-scheme
    (use defstruct debug srfi-69 srfi-9)
    
    (defstruct a (b 1))
    
    (let ((table (make-hash-table eq?))
          (a (make-a)))
      (hash-table-set! table a 2)
      (hash-table-ref table a)
      (a-b-set! a 2)
      ;; this throws an error! is it doing some sort of deep comparison,
      ;; or copy-on-write?
      (hash-table-ref table a))
    
  #+END_SRC

  #+BEGIN_SRC scheme :tangle test-range.scm :shebang #!/usr/bin/env chicken-scheme
    (use debug srfi-26)
    
    (define (clamp low high value)
      (max low (min high value)))
    
    (let ((min-n -1)
          (max-n 1)
          (x 9)
          (y -9)
          (z 0))
      (debug
       (map (cut clamp min-n max-n <>)
            (list x y z))))
    
  #+END_SRC

  how to visualize $t$: time series?

  #+BEGIN_SRC gnuplot :tangle oj.gp :shebang #!/usr/bin/env gnuplot
    plot "oj.dat" using 1 with lines, \
         "oj.dat" using 2 with lines, \
         "oj.dat" using 3 with lines, \
         "oj.dat" using 4 with lines, \
         "oj.dat" using 5 with lines
    
  #+END_SRC

  #+BEGIN_SRC scheme :tangle test-mkdtemp.scm :shebang #!/usr/bin/env chicken-scheme
    (use debug)
    (import foreign)
    (foreign-declare "#include <stdlib.h>")
    (debug ((foreign-lambda c-string "mkdtemp" c-string) "/tmp/XXXXXX"))
  #+END_SRC
* \protect\citetitle{maathius:2009}
  - Pearl: "an associational concept is any relationship that can be
    defined in termes of a joint distribution of observed variables,
    and a causal concept is any relationship that cannot be defined
    from the distribution alone. . . . Every claim invoking causal
    concepts must be trade to some premises that invoke such concepts;
    it cannot be inferred or derived from statistical associations
    alone."
  - a DAG is typically not identifiable from observational data,
    because conditional dependencies only determine the skeleton and
    the so-called v-structures of the graph.
  - a CPDAG can be estimated in various ways, including the
    PC-algorithm (Spirtes, P., Glymour, C. and Scheines,
    R. (2000). Causation, Prediction, and Search, 2nd ed. MIT Press,
    Cambridge, MA), search and score methods (Chickering,
    D. M. (2002). Learning equivalence classes of Bayesian-network
    structures. J. Mach. Learn. Res. 2 445–498, Chickering,
    D. M. (2003). Optimal structure identification with greedy
    search. J. Mach. Learn. Res. 3 507–554, Chow, C. and Liu,
    C. (1968). Approximating discrete probability distributions with
    dependence trees. IEEE Trans. Inform. Theory 14 462–467) and
    Bayesian methods (Heckerman, D., Geiger, D. and Chickering,
    D. (1995). Learning Bayesian networks: The combination of
    knowledge and statistical data. J. Mach. Learn. Res. 20 197–243,
    Spiegelhalter, D. J., Dawid, A. P., Lauritzen, S. L. and Cowell,
    R. G. (1993). Bayesian analysis in expert systems. Statist. Sci. 8
    219–283).
* \protect\citetitle{kalisch:2007}
  - R.E. Neapolitan. Learning Bayesian Networks. Pearson Prenctice
    Hall, 2004.
* \protect\citetitle{spirtes:2000}
  - we should like an algorithm that has the same input/output
    relations as the SGS procedure for faithful distributions but
    which for sparse graphs does not require the testing of higher
    order independence relations in the discrete case, and in any case
    requires testing as few d-separation relations as possible. the
    following procedure (spirtes, glymour and scheines 1991) starts by
    forming the complete undirected graph, then "thins" that graph by
    removing edges with zero order conditional indepedence relations,
    thins again with first order conditional independence relations,
    and so on. the set of variables conditioned on need only be a
    subset of the set of variables adjacent to one or the other of the
    variables conditioned.
* \protect\citetitle{spirtes:1991}
  - finding causal relations between variables is necessary . . . for
    these purposes, it is insufficient to merely fit an empirical
    covariance matrix or find the best least squares linear estimator
    of a variable.
    - Spirtes and Clark Glymour, Department of Philosophy, CMU; btw.
    - we'd essentially be discovering a causal network upon which to
      thagardize?
  - we will represent the direct causal dependence of one variable on
    another by a directed edge from a vertex representing the causal
    variable to a vertex representing the effect variable.
    - what about the skeleton sans causal inference: covariance
      matrix?
  - social scientist . . . must therefore restrict the space of
    alternatives: 1) experimental controls, 2) prior knowledge, 3)
    features of the sample data.
  - there is no evidence that such appeals constitute a reliable
    discovery procedure.
  - "substantive knowledge" rather than sample data should determine
    the causal structure of a model.
  - among the assumptions made by factor analytics programs is that
    the data functional dependencies between variables are linear, and
    that no measured variable directly causes either measured or
    latent variables . . . they are not essential to inferring causal
    structure from sample data.
  - . . . provide reliable procedures for using sample data to
    usefully narrow the class of causal structures that are, a priori,
    possible for the data.
  - pairs (g, P) for which g is a DAG and P is a probability
    distribution on the vertices of g such that 1) for every vertex v
    and set S_v of vertices that are not descendants or parents of v,
    v and S_v are independent conditional on the parents of v; and 2)
    every independence relation in P is a consequence of the
    independence relations in 1). pairs satisfying these conditions
    can be viewed as causal structures in which the causal
    dependencies generate statistical dependencies.
    - "not descendants or parents": siblings, if connected;
      orthogonal, if not.
  - when the set of measured variables for which probabilities are
    provided in the data is such that every common cause fo a measured
    variable is itself measured, we say the structure is causally
    sufficient.
    - how are the probabilities provided? "in the data".
    - ". . . every common cause of a measured variables is itself
      measured . . ."
  - recovery problem occur when determining g, or features of g, from
    the distribution P or from samples obtained from P.
    - ah, P and samples obtained (from a possibly unknown?) P are
      distinct.
  - SGS algorithm (Spirtes, et al. 1990. Causality from probability.):
    1. start with complete undirected graph
    2. for each vertex pair (a, b), remove the undirected edge between
       a anb b iff I(a, S, b) for some subset S not containing a or
       b. call this undirected graph G.
    3. for each triple (a, b, c) such that a and b are adjacent in G,
       b and c are adjacent in G, and a and c are not adjacent in G,
       direct the edges a-b and b-c into b iff for ever set S of
       vertices containing b but not a or c, ~I(a, S, C).
       - `~' signifies `not'?
    4. output all orientations of the graph consistent with 2.
       - for coming up with a skeleton, therefore, it suffices to
         eliminate edges with conditional independence? how to
         establish conditional independence: learn the conditional
         probabilities given a dataset?
* \protect\citetitle{verma:1990}
  - relationship between dags and dependence: given a -> b -> c, the
    parameters required are P(a), P(b|a), P(c|b); "required":
    requiring estimations.
  - P(a)P(b|a) = P(ab) = P(b)P(b|a) [P(a)P(b|a) = P(ab) because of
    compounding probabilities]
  - given {a, c} -> b: P(a), P(c), P(b|ac) [P(b|ac) = P(b|a) +
    P(b|c)?]
    - joint probability: conjunctive, multiplicative; marginal
      (unconditional): integrating (summing) the joint probabilities
      over all the outcomes of X: P(A) = P(AB) + P(AB'), etc.
    - prior probability: P(A|I), probability of A given initial
      information I; conditioning of probabilities: updating them to
      take account of (possibly new) information (Bayes' theorem).
    - conditional probability: probability of C under the condition
      that A is observed; P(C|A): "probability of C given A."
    - statistically independent: P(B|A) = P(B).
    - P(C|A) = P(AC) / P(A); P(AC) = P(C|A)P(A).
    - statistically independent: P(B) = P(B|A) = P(AB)/P(A);
      i.e. P(A)P(B) = P(AB).
    - Bayes' theorem: P(B|A) = P(A|B) * P(B) / P(A); P(A)P(B|A) =
      P(A|B)P(B); P(A|B) ~= P(B|A) iff P(A) ~= P(B).
  - I(a, b, c): "a is independent of c given b"; vs. I(a, nil, c): "a
    is marginally (unconditionally) independent of c".
  - the statistical meaning of any causal model can be described
    completely and economically by its *stratified protocol*, which is
    a list of independence statements, each asserting that a variable
    is independent of its non-descendants, given its parents.
    - produce dags negatively: by removing links based on
      independence?
  - furthermore, any independence statement that logically folows from
    the statified protocol can be graphically determined in linear
    time via the *d-separation* criterion (geiger, 89, 90)
    - uh, oh: time to learn d-separation
    - geiger, verma, pearl. 1989. d-separation: from theorems to
      algorithms.
    - geiger, pearl. 1990. logical and algorithmic properties of
      independence and their application to bayesion networks.
    - [[http://www.andrew.cmu.edu/user/scheines/tutor/d-sep.html][d-separation]]
      - can we specify an algorithm that will compute, for any
        directed graph interpreted as a linear statistical model, all
        and only those independence and conditional independence
        relations that hold for all values of the parameters (causal
        strengths)?
      - Pearl realized that uncertain information could be stored much
        more efficiently by taking advantage of conditional
        independence, and they used DAGs to encode probabilities and
        the conditional independence relations among them.
      - D-separation was the algorithm they invented to computed all
        the conditional independence relations entailed by their
        graphs.
        - Pearl, J. (1988). Probabilistic Reasoning in Intelligent
          Systems. Morgan and Kaufman, San Mateo.
      -   
  - the question of equivalence of caulas models reduces to the
    question of equivalence of protocols: two dags are equevalent iff
    each dag's protocol holds in the other.
  - it is difficult to process visually and it does not generalize to
    embedded causal models.
  - embedded causal models are useful for modeling theories that
    cannot be modeled via simple dags . . . if there are unobserved
    variables which cause spurious correlations between the observable
    variables it may be necessary to embed the observables in a larger
    dag containing "hidden" variables in order to build an accurate
    model.
  - it might be desirable to embed the model in a larger dag to
    satisfy some high level constraints. . . suppose that every causal
    model that fits a given set of data contains the link a -> b, but
    b is known to precede a. . . one way of avoiding this conflict is
    to hypothesize the existence of an unknown common cause, i.e. a <-
    α -> b.
  - unlink simple causal models, the statistical meaning of an
    embedded causal model cannot be completely characterized by
    dependency information alone; two dependency-equivalent causal
    models need not be equivalent in the general sense.
  - dependency equivalence is a tight enough necessary condition for
    equivalence that it permits many sound conclusions to be derived
    by graphical means.
  - previous two sections are applied to the problem of recovery of a
    causal model from statistical data.
  - 
#+BIBLIOGRAPHY: TODO jurabib
