# -*- org -*-
* TODO connectionist
# <<connectionist>>
  since $a_j(t + 1)$ depends on $a_j(t)$, we should calculate $t + 1$
  and then update the graph atomically: we can't let the $t + 1$
  contaminate $t$.
* TODO input specification
  can we just do something like this:
  
  #+BEGIN_SRC scheme
    (a 0.5)
    (b +high)
    (b -low)
    (c evidence)
    (a b +high)
    (c b -low)
    (a c 0.5)
  #+END_SRC

  or is that an appropriate way to handle evidence? do we need
  multiple evidence? let's just have a special (pre-existing) node to
  that effect:

  #+BEGIN_SRC scheme
    (a 0.5)
    (b +high)                               ; or (b high)
    (c -low)
    (a b +high)
    (evidence c -low)
    (a evidence 0.5)
  #+END_SRC

  so: we'll have nodes (activation) and links (weight, whence,
  whither); no name for now.

  actually:

  #+BEGIN_SRC scheme
    ;;; initial activations don't matter?
    (a)
    (b 0.5)
    (c 0.9 "Howdy Doody")
    
    (a b)
    (a c -0.5)
    
    (evidence a)
    (evidence c)
    
    ;;; all this (v. supra) is bad compared to the
    ;;; ({explain,contradict,...} ...) mechanisms; what's the big deal
    ;;; about key words, anyway?
    ;;; 
    ;;; would need to have the following to simulate (explain ...), etc.
    
    ((a b) c)
    ((a c) b -0.5)
    ((a b) evidence)
    
    ;;; should it look followingly instead?
    
    (use connectionist (decay 0.5) ...)
    
    (propose a)
    (propose b 0.75)
    (propose c -0.5 "Foo")
    
    ;;; though ECHO never really sets the initial activations for
    ;;; propositions; so maybe the following:
    
    (propose a)
    (propose b "Foo")
    (propose c "Bar")
    
    (explain (a c) b)
    (contradict (b) a)
    
    ;;; or simply:
    
    (contradict b a -0.75)
    
    (data a b)
    
    ;;; or maybe:
    
    (evidence a b)
    
    ;;; hmm.
  #+END_SRC

  what about joshua bloch's idea about starting with the API first?
  (see seibel's book.) hmm.

  #+BEGIN_SRC scheme :tangle influence.scm
    (module
     influence
     *
     (import scheme
             chicken)
    
     (use srfi-69
          defstruct
          matchable
          debug)
    
     (define default-activation (make-parameter 0.01))
     (define maximum-activation (make-parameter 0.99))
     (define minimum-activation (make-parameter -0.99))
    
     (define excitatory (make-parameter 0.04))
     (define inhibitory (make-parameter -0.06))
     (define default-weight (make-parameter (excitatory)))
    
     (define default-description (make-parameter ""))
    
     (define (default-description? description)
       (string=? description (default-description)))
    
     (defstruct proposition
       name
       (activation (default-activation))
       (description (default-description))
       ;; propositions are trivially accepted, rejected or something
       ;; orthogonal? a default of #t is trivially optimistic.
       (accepted? #t)
       (evidence? #f))
    
     (define evidence
       (make-proposition
        name: 'evidence
        activation: (maximum-activation)
        description: "Evidence"
        evidence?: #t))
    
     (define (evidence? proposition)
       (eq? evidence proposition))
    
     (defstruct constraint
       (weight (default-weight))
       whither)
    
     (defstruct problem
       (propositions
        ;; should we rethink this at some point?
        (let ((propositions (make-hash-table eq? hash-by-identity))) 
          (hash-table-set! propositions 'evidence evidence)
          propositions))
       (constraints (make-hash-table eq? hash-by-identity)))
    
     (define current-problem (make-parameter (make-problem)))
    
     (define link!
       (case-lambda
        ((problem whence whither)
         (link! problem whence whither (default-weight)))
        ((problem whence whither weight)
         (let* ((whither (hash-table-ref (problem-propositions problem)
                                         whither))
                (constraint (make-constraint weight: weight
                                             whither: whither)))
           (hash-table-update!/default
            (problem-constraints problem)
            whence
            (cut cons constraint <>)
            '())))))
    
    ;;; explain, contradict should call link-symmetrically! with
    ;;; e.g. certain default weights.
     (define link-symmetrically!
       (case-lambda
        ((problem whence whither)
         (link-symmetrically! problem whence whither (default-weight)))
        ((problem whence whither weight)
         (link! problem whence whither weight)
         (link! problem whither whence weight)))) 
    
     (define cohere!
       (case-lambda
        ((cohaeretors cohaerendum)
         (cohere! cohaeretors cohaerendum (default-weight)))
        ((cohaeretors cohaerendum weight)
         (cohere! (current-problem) cohaeretors cohaerendum weight))
        ((problem cohaeretors cohaerendum weight)
         (for-each
          (cut link-symmetrically! problem cohaerendum <> weight)
          cohaeretors)
         #;
         (let ((propositions (problem-propositions problem))
               (constraints (problem-constraints problem)))
           (let ((cohaerendum (hash-table-ref propositions cohaerendum)))
             (for-each
              (lambda (cohaeretor)
                (let ((cohaeretor (hash-table-ref propositions cohaeretor)))
                  (link-symmetrically! constraints cohaeretor cohaerendum weight)))
              cohaeretors))))))
    
    ;;; or maybe explain should do the symbol lookup, etc.
     (define explain!
       (case-lambda
        ((explanators explanandum)
         (explain! (current-problem) explanators explanandum))
        ((problem explanators explanandum)
         (cohere! problem explanators explanandum (excitatory)))))
    
     (define contradict!
       (case-lambda
        ((contradictors contradictum)
         (contradict! (current-problem) contradictors contradictum))
        ((problem contradictors contradictum)
         (cohere! problem contradictors contradictum (inhibitory)))))
    
     (define evidence!
       (case-lambda
        ((evidenced)
         (evidence! (current-problem) evidenced))
        ((problem evidenced)
         (explain! evidenced 'evidence))))
    
     (define propose!
       (case-lambda
        ((name)
         (propose! name (default-description)))
        ((name description)
         (propose! name description (default-activation)))
        ((name description activation)
         (propose! (current-problem) name description activation))
        ((problem name description activation)
         (hash-table-set!
          (problem-propositions problem)
          name
          (make-proposition name: name
                            activation: activation
                            description: description)))))
    
     (define (with-problem problem thunk)
       (parameterize ((current-problem problem)) (thunk))))    
    
  #+END_SRC

  do we want to have in-place mutation of the graph, btw? if we do a
  =hash-table-copy=, we're still going to have references to nodes;
  i'm beginning to see why david did the matrix thing.

  we're going to have to deep-copy the hash table in that case; if we
  merely used lists instead of e.g. node- and link-objects, that
  wouldn't be the case.

  bizarre, isn't it, that all nodes (save evidence) start off with an
  activation of 0.01? the input activations make no
  difference. interesting!

  what about abstractions like =proposition=, =explain=, =contradict=,
  etc.?

  otherwise, if we do an in-place calculation, we still have to hold
  $t + 1$ while calculating $t$ (see [[connectionist]]).

  if we're doing symmetrical links, btw, can't we have incoming and
  outgoing hash tables? although there's a space penalty, it becomes
  trivial to calculate McClelland's $S_j$: "the sum of the excitatory
  and inhibitory influences on unit $j$."

  incoming and outgoing hash-tables are orthogonal to symmetry;
  matrix-wise, however, aren't we dealing with transposing the
  adjacency matrix?

  in fact, we'd need two outgoing and two incoming links for each
  relationship in a symmetrical graph.

  #+BEGIN_SRC scheme :tangle test-hash-table.scm :shebang #!/usr/bin/env chicken-scheme
    (use srfi-69 debug test)
    
    (let ((table (make-hash-table)))
      (hash-table-update!/default
       table
       'a
       (lambda (value)
         (cons 1 value))
       '())
      (test
       "the default is passed to lambda as-is"
       '((a 1))
       (hash-table->alist table)))
  #+END_SRC

  thagard speaks of networks, units, links; but also: elements,
  constraints that underly the units and links. also: coherence
  problem, hypotheses.

  "In coherence theories of truth, the elements are propositions
  . . ." so we also have propositions.

  "Positive constraints can be a variety of relations among
  propositions, including entailment and also more complex relations
  such as explanation. The negative constraints can include
  inconsistency, but also weaker constraints such as competition."

  "Positive constraints arise from relations of explanation and
  analogy that hold between propositions, and negative constraints
  arise either because two hypotheses contradict each other or because
  they compete with each other to explain the same evidence."

  =echo-input.lisp= has: =(defun imply (lst prop) (explain lst
  prop))=, which is at least one synonym. but, in general,
  =proposition=, =explain=, =contradict= seem to suffice for the
  examples.

  let's have: problem, proposition, constraint.

  problem contexts for proposition, explain, et.nc

  #+BEGIN_SRC scheme :tangle test-with-parameter.scm :shebang #!/usr/bin/env chicken-scheme
    (use srfi-39 test)
    
    (define current-a (make-parameter 1))
    
    (define (with-a a thunk)
      (parameterize ((current-a a)) (thunk)))
    
    (with-a 2 (lambda () (test 2 (current-a))))
    
    (test 1 (current-a))
  #+END_SRC

  the verb associated with the bipartition of E into A and R is
  "satisfy": one "satisfies" a coherence problem. no, sorry; that's
  not true: one "solves" a coherence problem. (makes sense!)

  #+BEGIN_QUOTE
  To show that a given problem is a coherence problem in this sense,
  it is necessary to specify the elements and constraints, provide an
  interpretation of acceptance and rejection, and show that solutions
  to the given problem do in fact involve satisfaction of the
  specified constraints.
  #+END_QUOTE

  #+BEGIN_SRC scheme :tangle test-oj-problem.scm :shebang #!/usr/bin/env chicken-scheme
    (include "influence.scm")
    (import foreign influence)
    (use debug
         srfi-1
         matchable
         format
         posix
         foof-loop
         shell)
    
    (foreign-declare "#include <stdlib.h>")
    (define mkdtemp (foreign-lambda c-string "mkdtemp" c-string))
    
    (define maximum-iterations (make-parameter 5000))
    
    (define decay (make-parameter 0.05))
    
    (define epsilon (make-parameter 0.001))
    
    (define initial-activation (make-parameter (default-activation)))
    
    (define (display-problem/dot problem)
      (define (activation->saturation activation)
        (- 255 (inexact->exact (floor (* (/ activation (if (positive? activation)
                                                           (maximum-activation)
                                                           (minimum-activation)))
                                         255)))))
      
      (let ((document "digraph G { graph [size=\"12!\", ratio=0.618033989]; node [style=filled]; edge [dir=none]; ~a ~a }"))
        ;; what about writing right away, and not gathering?
        (let ((propositions
               (hash-table-fold
                (problem-propositions problem)
                (lambda (name proposition nodes)
                  (cons
                   (let* ((activation (proposition-activation proposition))
                          (saturation (activation->saturation activation)))
                     (format "\"~a\" [label=\"~a\", fillcolor=\"#~a~a~a\"];"
                             name
                             (let ((description
                                    (proposition-description proposition)))
                               (if (default-description? description)
                                   name
                                   #;description
                                   name
                                   ))
                             (format "~2,48X" (if (negative? activation)
                                                  255
                                                  saturation))
                             (format "~2,48X" (if (positive? activation)
                                                  255
                                                  saturation))
                             (format "~2,48X" saturation)))
                   nodes))
                '()))
              ;; respect sign and scale with dashed/solid and thickness?
              (constraints
               (map
                (match-lambda
                    ((whence whither . weight)
                     (format "\"~a\" -> \"~a\" [style=~a];"
                             whence
                             whither
                             (if (positive? weight)
                                 "solid"
                                 "dashed"))))
                ;; it's damn-expensive to delete one edge in a
                ;; bidirectional graph; we might want to consider
                ;; switching to a unidirectional graph, simulating
                ;; bidirectionality.
                (delete-duplicates
                 (hash-table-fold
                  (problem-constraints problem)
                  (lambda (name constraints edges)
                    (append
                     (map (lambda (constraint)
                            (cons* name
                                   (proposition-name
                                    (constraint-whither constraint))
                                   (constraint-weight constraint)))
                          constraints)
                     edges))
                  '())
                 (lambda (edge-a edge-b)
                   (match-let (((a-whence a-whither . a-weight) edge-a)
                               ((b-whence b-whither . b-weight) edge-b))
                     (and (eq? a-whence b-whither)
                          (eq? b-whence a-whither))))))))
          (format #t
                  document
                  (string-join propositions)
                  (string-join constraints)))))
    
    (define (clamp low high value)
      (max low (min high value)))
    
    (define (cardinality integer base)
      (loop ((for power (up-from 0))
             (until (> (expt base power) integer))) => power))
    
    (define solve!
      (case-lambda
       (() (solve! (current-problem)))
       ((problem)
        (let ((propositions (problem-propositions problem))
              (constraints (problem-constraints problem))
              (time-series-data (open-output-file "oj.dat"))
              (temp-dir (mkdtemp "/tmp/XXXXXX"))
              (temp-digits (cardinality (maximum-iterations) 10))
              (animation "oj.gif"))
          (hash-table-walk
           propositions
           (lambda (name proposition)
             (if (not (proposition-evidence? proposition))
                 (proposition-activation-set! proposition (initial-activation)))))
          (let iterate ((iteration 0)
                        (delta +Inf))
            (if (or (< (abs delta) (epsilon))
                    (> iteration (maximum-iterations)))
                (begin
                  (run (convert "$(" find ,temp-dir -name \'*.gif\' \| sort && find ,temp-dir -name \'*.gif\' \| sort -r ")" -loop 0 ,animation))
                  problem)
                (let ((activations
                       (hash-table-fold
                        propositions
                        (lambda (name proposition activations)
                          (let ((activation
                                 (if (proposition-evidence? proposition)
                                     (proposition-activation proposition)
                                     (let ((incoming-activation
                                            (let ((constraints (hash-table-ref constraints name)))
                                              (apply +
                                                     (map *
                                                          (map constraint-weight constraints)
                                                          (map (compose proposition-activation
                                                                        constraint-whither)
                                                               constraints)))))
                                           (activation (proposition-activation proposition)))
                                       (+ (* activation (- 1 (decay)))
                                          (* incoming-activation
                                             (if (positive? incoming-activation)
                                                 (- (maximum-activation) activation)
                                                 (- activation (minimum-activation)))))))))
                            (alist-cons name
                                        (clamp (minimum-activation)
                                               (maximum-activation)
                                               activation)
                                        activations)))
                        '())))
                  (display (string-join
                            (map
                             (compose number->string proposition-activation)
                             (hash-table-values propositions)))
                           time-series-data)
                  (newline time-series-data)
                  ;; do we need this read step, or can we simply update and take
                  ;; the delta? let's update and take the delta. no; unless we
                  ;; mutate, we need to read the delta.
                  (let ((delta
                         (apply +
                                (map (match-lambda
                                         ((name . activation)
                                          (- activation
                                             (proposition-activation
                                              (hash-table-ref propositions name)))))
                                     activations)))) 
                    (for-each (match-lambda
                                  ((name . activation)
                                   (hash-table-update! propositions
                                                       name
                                                       (lambda (proposition)
                                                         (proposition-activation-set!
                                                          proposition
                                                          activation)
                                                         proposition))))
                              activations)
                    (let*-values (((output-template)
                                   (format "~~~a,48d.gif" temp-digits))
                                  ((in out id)
                                   (process "dot" `("-Tgif"
                                                    "-o" ,(make-pathname
                                                           temp-dir
                                                           (format output-template
                                                                   iteration))))))
                      (close-input-port in)
                      (with-output-to-port
                          out
                        (lambda () (display-problem/dot problem)))
                      (close-output-port out))
                    (iterate (add1 iteration)
                             delta)))))))))
    
    (let ((oj (make-problem)))
      (with-problem
       oj
       (lambda ()
         (propose! 'oj-abusive)
         (propose! 'oj-beat-nicole)
         (propose! 'oj-killed-nicole)
         (propose! 'nicole-and-ron-were-killed)
         (propose! 'blood-on-sock)
         (propose! 'blood-in-ojs-car)
         (propose! 'bloody-glove)
         (propose! 'bloody-gate)
         (propose! 'fuhrman-lied)
         (propose! 'edta-on-sock)
         (propose! 'drug-dealers-killed-nicole)
         (propose! 'the-lapd-framed-oj)
    
         (explain! '(oj-beat-nicole oj-killed-nicole) 'oj-abusive)
         (explain! '(blood-on-sock
                     blood-in-ojs-car
                     bloody-glove
                     bloody-gate
                     fuhrman-lied
                     edta-on-sock)
                   'the-lapd-framed-oj)
         (explain! '(nicole-and-ron-were-killed)
                   'drug-dealers-killed-nicole)
    
         (contradict! '(drug-dealers-killed-nicole
                        the-lapd-framed-oj)
                      'oj-killed-nicole)
    
         (evidence! '(oj-beat-nicole
                      nicole-and-ron-were-killed
                      blood-on-sock
                      blood-in-ojs-car
                      bloody-glove
                      bloody-gate
                      fuhrman-lied
                      edta-on-sock)) 
    
         (display-problem/dot (solve! oj)))))
    
    #;
    (with-problem
     (make-problem)
     (lambda ()
       (propose! 'e1)
       (propose! 'e2)
       (propose! 'e3)
       (propose! 'e4)
    
       (explain! '(e3 e4) 'e1)
       (explain! '(e4) 'e2)
    
       (contradict! '(e1) 'e2)
    
       (evidence! '(e1))
    
       (display-problem/dot (solve! (current-problem)))))
    
    #;
     (with-problem
      (make-problem)
      (lambda ()
        (propose! 'E1 "In combustion, heat and light are given off.")
        (propose! 'E2 "Inflammability is transmittable from one body to another.")
        (propose! 'E3 "Combustion only occurs in the presence of pure air.")
        (propose! 'E4 "Increase in weight of a burned body is exactly equal to weight of air absorbed. ")
        (propose! 'E5 "Metals undergo calcination.")
        (propose! 'E6 "In calcination, bodies increase weight.")
        (propose! 'E7 "In calcination, volume of air diminishes.") ; 628
        (propose! 'E8 "In reduction, effervescence appears.")      ; 628
    
        (propose! 'OH1 "Pure air contains oxygen principle.") ; 625
        (propose! 'OH2 "Pure air contains matter of fire and heat (MFH).") ;
        (propose! 'OH3 "In combustion, oxygen from the air combines with the burning body.")
        (propose! 'OH4 "Oxygen has weight.")
        (propose! 'OH5 "In calcination, metals add oxygen to become calxes. ")
        (propose! 'OH6 "In reduction, oxygen is given off.") ; 628
    
        (propose! 'PH1 "Combustible bodies contain phlogiston.")    ; 624
        (propose! 'PH2 "Combustible bodies contain matter of heat.") ; 652
        (propose! 'PH3 "In combustion, phlogiston is given off.")    ; 624
        (propose! 'PH4 "Phlogiston can pass from one body to another.") ; 625
        (propose! 'PH5 "Metals contain phlogiston.")              ; 624
        (propose! 'PH6 "In calcination, phlogiston is given off.") ; 624
    
                                            ; Contradictions:
    
        (contradict! '(PH3) 'OH3)
        (contradict! '(PH6) 'OH5)           ; 652
    
                                            ; Oxygen explanations:
        (explain! '(OH1 OH2 OH3) 'E1)
                                            ; E2?
        (explain! '(OH1 OH3) 'E3)
        (explain! '(OH1 OH3 OH4) 'E4)
        (explain! '(OH1 OH5) 'E5)
        (explain! '(OH1 OH4 OH5) 'E6)
        (explain! '(OH1 OH5) 'E7)
        (explain! '(OH1 OH6) 'E8)
    
                                            ; Phlogiston explanations:
        (explain! '(PH1 PH2 PH3) 'E1)
        (explain! '(PH1 PH3 PH4) 'E2)
        (explain! '(PH5 PH6) 'E5)
    
        (evidence! '(E1 E2 E3 E4 E5 E6 E7 E8))
    
        (display-problem/dot (solve! (current-problem)))))
    
  #+END_SRC

  what does it mean to solve a coherence problem, btw? bipartition of
  propositions into accepted or rejected. if we're doing this
  in-place, we can simply set a flag on the proposition to =accepted?
  => #t=.

  think along the lines of =(solve problem solver)=, where =solver= is
  e.g. connectionist instantiated with certain parameters =(decay
  0.5)=, etc.

  #+BEGIN_SRC scheme :tangle test-fold.scm :shebang #!/usr/bin/env chicken-scheme
    (use srfi-1 debug)
    
    (debug
     (fold (lambda (a b c)
             (debug a b c)
             (+ a b c))
           0
           '(1 2)
           '(3 4)))
    
  #+END_SRC

  figure out a way to [[http://orgmode.org/manual/System_002dwide-header-arguments.html#System_002dwide-header-arguments][set the default :shebang]]; this doesn't work:

  #+BEGIN_SRC elisp
    (setq org-babel-default-header-args:scheme
          '((:shebang . "#!/usr/bin/env chicken-scheme")))
  #+END_SRC

  [[http://www.mail-archive.com/emacs-orgmode@gnu.org/msg37217.html][see this]].

  #+BEGIN_SRC scheme :tangle test-equality.scm :shebang #!/usr/bin/env chicken-scheme
    (use defstruct debug srfi-69 srfi-9)
    
    (defstruct a (b 1))
    
    (let ((table (make-hash-table eq?))
          (a (make-a)))
      (hash-table-set! table a 2)
      (hash-table-ref table a)
      (a-b-set! a 2)
      ;; this throws an error! is it doing some sort of deep comparison,
      ;; or copy-on-write?
      (hash-table-ref table a))
    
  #+END_SRC

  #+BEGIN_SRC scheme :tangle test-range.scm :shebang #!/usr/bin/env chicken-scheme
    (use debug srfi-26)
    
    (define (clamp low high value)
      (max low (min high value)))
    
    (let ((min-n -1)
          (max-n 1)
          (x 9)
          (y -9)
          (z 0))
      (debug
       (map (cut clamp min-n max-n <>)
            (list x y z))))
    
  #+END_SRC

  how to visualize $t$: time series?

  #+BEGIN_SRC gnuplot :tangle oj.gp :shebang #!/usr/bin/env gnuplot
    plot "oj.dat" using 1 with lines, \
         "oj.dat" using 2 with lines, \
         "oj.dat" using 3 with lines, \
         "oj.dat" using 4 with lines, \
         "oj.dat" using 5 with lines
    
  #+END_SRC

  #+BEGIN_SRC scheme :tangle test-mkdtemp.scm :shebang #!/usr/bin/env chicken-scheme
    (use debug)
    (import foreign)
    (foreign-declare "#include <stdlib.h>")
    (debug ((foreign-lambda c-string "mkdtemp" c-string) "/tmp/XXXXXX"))
  #+END_SRC
